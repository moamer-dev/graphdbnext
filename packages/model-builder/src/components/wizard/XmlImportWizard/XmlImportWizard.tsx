'use client'

import { useEffect } from 'react'
import { Upload, AlertCircle, FileText, Settings, Eye, CheckCircle2, ChevronDown } from 'lucide-react'
import { Button } from '../../ui/button'
import { UploadStep } from './steps/UploadStep'
import { ConfigureRulesStep } from './steps/ConfigureRulesStep'
import { AnalyzeStep } from './steps/AnalyzeStep'
import { ConfigureStep } from './steps/ConfigureStep'
import { ReviewStep } from './steps/ReviewStep'
import { useXmlImport } from '../../../hooks/useXmlImport'
import { useXmlImportWizardStore, type WizardStep } from '../../../stores/xmlImportWizardStore'
import { useXmlImportWizardUI } from '../../../hooks/wizard/useXmlImportWizardUI'
import { extractXmlElements } from '../../../utils/xmlElementExtractor'
import { cn } from '../../../utils/cn'
import type { XmlMappingConfig, XmlAnalysisRules } from '../../../services/xmlAnalyzer'
import { downloadFile } from '../../../utils/exportUtils'

interface XmlImportWizardProps {
  onImportComplete?: () => void
  className?: string
}

export function XmlImportWizard ({ onImportComplete, className }: XmlImportWizardProps) {
  const ui = useXmlImportWizardUI()
  const {
    fileInputRef,
    extracting,
    setExtracting,
    showStructure,
    setShowStructure,
    showMapping,
    setShowMapping,
    xmlPreview,
    setXmlPreview,
    importingConfig,
    setImportingConfig,
    importingRules,
    setImportingRules,
    addingItems,
    setAddingItems,
    removingItems,
    setRemovingItems
  } = ui
  
  // Zustand store for wizard state
  const {
    step,
    selectedFile,
    analysisRules,
    selectedElements,
    availableElements,
    error: wizardError,
    setStep,
    setSelectedFile,
    setAnalysisRules,
    setSelectedElements,
    setAvailableElements,
    toggleElement,
    selectElements,
    setError: setWizardError,
    reset: resetWizard
  } = useXmlImportWizardStore()
  
  // Hook for XML import operations
  const {
    analysis: hookAnalysis,
    mapping: hookMapping,
    error: hookError,
    analyzeXml,
    updateMapping,
    generateModel,
    loadModel,
    reset: resetImport,
    clearError
  } = useXmlImport()
  
  // Get analysis and mapping from store (prefer store over hook for persistence)
  const analysis = useXmlImportWizardStore(state => state.analysis) || hookAnalysis
  const mapping = useXmlImportWizardStore(state => state.mapping) || hookMapping
  const error = wizardError || hookError

  type XmlWizardConfigExport = {
    version: 1
    fileName?: string
    createdAt: string
    analysisRules: Partial<XmlAnalysisRules>
    mapping: XmlMappingConfig | null
  }

  type XmlWizardRulesExport = {
    version: 1
    type: 'xml-rules'
    fileName?: string
    createdAt: string
    analysisRules: Partial<XmlAnalysisRules>
  }

  const handleFileSelect = async (file: File) => {
    if (!file.name.endsWith('.xml')) {
      clearError()
      setWizardError(null)
      return
    }

    // If this is a different file, clear previous analysis and mapping
    // Only clear if we have a current file and it's different
    const currentFile = selectedFile || useXmlImportWizardStore.getState().selectedFile
    if (currentFile && currentFile.name !== file.name) {
      // New file uploaded - reset analysis and mapping
      useXmlImportWizardStore.getState().setAnalysis(null)
      useXmlImportWizardStore.getState().setMapping(null)
      resetImport()
    }

    setSelectedFile(file)
    setExtracting(true)
    
    // Extract element names and attributes for dropdowns
    try {
      const elementInfo = await extractXmlElements(file)
      setAvailableElements(elementInfo)
      console.log('Extracted elements:', elementInfo.elementNames.length, 'elements,', elementInfo.attributeNames.length, 'attributes')
      if (elementInfo.elementNames.length === 0) {
        console.warn('No elements found in XML. First 500 chars of XML:', file.name)
      }
    } catch (error) {
      console.error('Failed to extract XML elements:', error)
      const errorMessage = error instanceof Error ? error.message : 'Unknown error'
      setWizardError(`Failed to extract XML elements: ${errorMessage}`)
      // Continue even if extraction fails - user can still type manually
      setAvailableElements(null)
    } finally {
      setExtracting(false)
    }
    
    setStep('configure-rules')
  }

  const handleAnalyze = async () => {
    if (!selectedFile) return
    
    setStep('analyze')
    setWizardError(null)
    const result = await analyzeXml(selectedFile, analysisRules)
    if (result) {
      // Store analysis in Zustand store
      useXmlImportWizardStore.getState().setAnalysis(result)
      
      // Wait a bit for mapping to be generated, then auto-select elements
      // The mapping is generated by the hook after analysis
      setTimeout(() => {
        const currentMapping = hookMapping || useXmlImportWizardStore.getState().mapping
        if (currentMapping) {
          const included = new Set(
            Object.entries(currentMapping.elementMappings)
              .filter(([, config]) => config.include)
              .map(([name]) => name)
          )
          setSelectedElements(included)
        }
      }, 100)
      
      setStep('configure')
    }
  }

  const handleMappingChange = (newMapping: XmlMappingConfig) => {
    // Batch state updates using React's automatic batching (React 18+)
    // Update selected elements first (cheaper operation)
    // Ensure elementMappings exists and is an object
    const elementMappings = newMapping?.elementMappings || {}
    const included = new Set(
      Object.entries(elementMappings)
        .filter(([, config]) => config?.include)
        .map(([name]) => name)
    )
    setSelectedElements(included)
    
    // Then update mapping (triggers re-renders in child components)
    updateMapping(newMapping)
    // Store mapping in Zustand store
    useXmlImportWizardStore.getState().setMapping(newMapping)
  }

  const handleAddElementsToMapping = (elementNames: string[]) => {
    if (!analysis || !mapping) return
    
    // Automatically show mapping panel if it's hidden
    if (!showMapping) {
      setShowMapping(true)
    }
    
    // Only copy what we need to modify - more efficient
    const newElementMappings = { ...mapping.elementMappings }
    const newAttributeMappings = { ...mapping.attributeMappings }
    
    // Process each element
    elementNames.forEach((name) => {
      const elementType = analysis.elementTypes.find((et) => et.name === name)
      if (!elementType) return
      
      // Update element mapping
      const existing = newElementMappings[name] || {
        include: false,
        nodeLabel: name,
        nodeType: name,
        superclassNames: []
      }
      newElementMappings[name] = {
        ...existing,
        include: true
      }
      
      // Update attribute mappings - only copy if needed
      if (!newAttributeMappings[name]) {
        newAttributeMappings[name] = {}
      } else {
        // Only create new object if we're modifying it
        newAttributeMappings[name] = { ...newAttributeMappings[name] }
      }
      
      elementType.attributes.forEach((attrName) => {
        if (!newAttributeMappings[name][attrName]) {
          const attrAnalysis = elementType.attributeAnalysis[attrName]
          const attrType = attrAnalysis?.type || 'string'
          newAttributeMappings[name][attrName] = {
            include: true,
            propertyKey: attrName,
            propertyType: (attrType === 'id-reference' || attrType === 'xpath-reference') ? 'string' : attrType,
            required: attrAnalysis?.required || false,
            isReference: attrAnalysis?.isReference || false
          }
        } else {
          // Only update if not already included
          if (!newAttributeMappings[name][attrName].include) {
            newAttributeMappings[name][attrName] = {
              ...newAttributeMappings[name][attrName],
              include: true
            }
          }
        }
      })
    })
    
    // Create new mapping object only with changed parts
    const newMapping: XmlMappingConfig = {
      ...mapping,
      elementMappings: newElementMappings,
      attributeMappings: newAttributeMappings
      // relationshipMappings doesn't change, so we can reuse the reference
    }
    
    handleMappingChange(newMapping)
  }

  const handleRemoveElementsFromMapping = async (elementNames: string[]) => {
    if (!mapping || elementNames.length === 0) return
    
    // Set removing items state
    setRemovingItems(new Set(elementNames))
    
    try {
      // Use setTimeout to allow UI to update
      await new Promise<void>((resolve) => {
        setTimeout(() => {
          const newMapping: XmlMappingConfig = {
            ...mapping,
            elementMappings: { ...mapping.elementMappings },
            attributeMappings: { ...mapping.attributeMappings },
            relationshipMappings: { ...mapping.relationshipMappings }
          }
          elementNames.forEach((name) => {
            if (newMapping.elementMappings[name]) {
              newMapping.elementMappings[name] = { ...newMapping.elementMappings[name], include: false }
            }
            Object.keys(newMapping.relationshipMappings).forEach((relKey) => {
              if (relKey.startsWith(`${name}->`) || relKey.includes(`->${name}`)) {
                delete newMapping.relationshipMappings[relKey]
              }
            })
          })
          handleMappingChange(newMapping)
          resolve()
        }, 0)
      })
    } finally {
      // Small delay to ensure state updates are visible
      setTimeout(() => {
        setRemovingItems(new Set())
      }, 100)
    }
  }

  const handleElementDelete = (elementNames: string[]) => {
    if (!mapping) return
    
    const newMapping = { ...mapping }
    
    // Remove from element mappings
    elementNames.forEach((name) => {
      delete newMapping.elementMappings[name]
      delete newMapping.attributeMappings[name]
      
      // Remove from relationship mappings
      Object.keys(newMapping.relationshipMappings).forEach((relKey) => {
        if (relKey.includes(name)) {
          delete newMapping.relationshipMappings[relKey]
        }
      })
    })
    
    updateMapping(newMapping)
    useXmlImportWizardStore.getState().setMapping(newMapping)
    
    // Update selected elements
    const newSelected = new Set(selectedElements)
    elementNames.forEach((name) => newSelected.delete(name))
    setSelectedElements(newSelected)
  }

  const handleGenerate = () => {
    const result = generateModel()
    if (result) {
      loadModel(result, {
        name: selectedFile?.name.replace('.xml', '') || 'Imported XML Schema',
        description: `Imported from ${selectedFile?.name || 'XML file'}`,
        version: '1.0.0'
      })
      setStep('review')
      onImportComplete?.()
    }
  }

  const handleReset = () => {
    resetWizard()
    resetImport()
    if (fileInputRef.current) {
      fileInputRef.current.value = ''
    }
  }

  const handleClearError = () => {
    clearError()
    setWizardError(null)
  }


  const handleExportConfig = () => {
    if (!selectedFile || !mapping) return
    const payload: XmlWizardConfigExport = {
      version: 1,
      fileName: selectedFile.name,
      createdAt: new Date().toISOString(),
      analysisRules,
      mapping
    }
    const json = JSON.stringify(payload, null, 2)
    const base = selectedFile.name.replace(/\.xml$/i, '') || 'xml-config'
    downloadFile(json, `${base}-config.json`, 'application/json;charset=utf-8;')
  }

  const handleExportRules = () => {
    if (!selectedFile) return
    const trimmedRules: Partial<XmlAnalysisRules> = {
      ignoredElements: analysisRules.ignoredElements || [],
      ignoredSubtrees: analysisRules.ignoredSubtrees || [],
      referenceAttributes: analysisRules.referenceAttributes || [],
      textContentRules: analysisRules.textContentRules || {
        characterLevelElements: [],
        signLevelElements: []
      }
    }
    const payload: XmlWizardRulesExport = {
      version: 1,
      type: 'xml-rules',
      fileName: selectedFile.name,
      createdAt: new Date().toISOString(),
      analysisRules: trimmedRules
    }
    const base = selectedFile.name.replace(/\.xml$/i, '') || 'xml-rules'
    const json = JSON.stringify(payload, null, 2)
    downloadFile(json, `${base}-rules.json`, 'application/json;charset=utf-8;')
  }

  const handleImportRules = async (file: File) => {
    if (!selectedFile) {
      setWizardError('Please upload the XML file before importing rules.')
      return
    }
    setImportingRules(true)
    try {
      const text = await file.text()
      const data = JSON.parse(text) as XmlWizardRulesExport
      if (!data || typeof data !== 'object' || data.type !== 'xml-rules') {
        setWizardError('Invalid rules file.')
        return
      }
      setAnalysisRules(data.analysisRules || {})
    } catch (err) {
      console.error('Failed to import XML rules:', err)
      setWizardError('Failed to import rules.')
    } finally {
      setImportingRules(false)
    }
  }

  const handleImportConfig = async (file: File) => {
    if (!selectedFile) {
      setWizardError('Please upload the XML file before importing configuration.')
      return
    }
    setImportingConfig(true)
    try {
      const text = await file.text()
      const data = JSON.parse(text) as XmlWizardConfigExport
      if (!data || typeof data !== 'object') {
        setWizardError('Invalid configuration file.')
        return
      }
      // Apply rules
      setAnalysisRules(data.analysisRules || {})
      // Re-run analysis with imported rules
      const result = await analyzeXml(selectedFile, data.analysisRules)
      if (!result) return
      // Apply mapping snapshot if present
      if (data.mapping) {
        handleMappingChange(data.mapping)
      }
      setStep('configure')
    } catch (err) {
      console.error('Failed to import XML config:', err)
      setWizardError('Failed to import configuration.')
    } finally {
      setImportingConfig(false)
    }
  }

  // Load XML preview when entering configure step (for Document Tree)
  useEffect(() => {
    const loadPreview = async () => {
      if (step !== 'configure' || !selectedFile || xmlPreview) return
      try {
        const text = await selectedFile.text()
        const formatted = formatXml(text)
        setXmlPreview(formatted)
      } catch (err) {
        console.error('Failed to load XML preview', err)
        setXmlPreview(null)
      }
    }
    loadPreview()
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [step, selectedFile, xmlPreview])

  const formatXml = (input: string) => {
    try {
      const parser = new DOMParser()
      const doc = parser.parseFromString(input, 'application/xml')
      const serializer = new XMLSerializer()
      const raw = serializer.serializeToString(doc)
      const PADDING = '  '
      const reg = /(>)(<)(\/*)/g
      const xml = raw.replace(reg, '$1\r\n$2$3')
      let pad = 0
      return xml.split('\r\n').map((line) => {
        let indent = ''
        if (line.match(/.+<\/\w[^>]*>$/)) {
          indent = PADDING.repeat(pad)
        } else if (line.match(/^<\/\w/)) {
          pad = Math.max(pad - 1, 0)
          indent = PADDING.repeat(pad)
        } else if (line.match(/^<\w[^>]*[^\/]>.*$/)) {
          indent = PADDING.repeat(pad)
          pad += 1
        } else {
          indent = PADDING.repeat(pad)
        }
        return indent + line
      }).join('\r\n')
    } catch {
      return input
    }
  }


  // Determine which steps are accessible
  const canAccessStep = (targetStep: WizardStep): boolean => {
    switch (targetStep) {
      case 'upload':
        return true // Always accessible
      case 'configure-rules':
        return !!selectedFile // Requires file
      case 'analyze':
        return !!selectedFile && Object.keys(analysisRules).length > 0 // Requires file and rules
      case 'configure':
        return !!analysis && !!mapping // Requires analysis
      case 'review':
        return !!analysis && !!mapping // Requires analysis (same as configure)
      default:
        return false
    }
  }

  const handleStepClick = (targetStep: WizardStep) => {
    if (canAccessStep(targetStep) && targetStep !== step) {
      setStep(targetStep)
    }
  }

  const wizardContent = (
    <div className={cn('flex gap-4', className)}>
      {/* Vertical Step Indicator on Left */}
      <div className="bg-muted/30 rounded-lg p-3 shrink-0 w-32">
        <div className="flex flex-col items-center gap-2">
          <button
            type="button"
            onClick={() => handleStepClick('upload')}
            disabled={!canAccessStep('upload')}
            className={cn(
              'flex flex-col items-center gap-1.5 px-2 py-2 rounded-md transition-all w-full',
              step === 'upload' && 'bg-primary text-primary-foreground shadow-sm',
              canAccessStep('upload') && step !== 'upload' && 'hover:bg-muted',
              !canAccessStep('upload') && 'opacity-50 cursor-not-allowed'
            )}
          >
            <Upload className={cn('h-5 w-5', step === 'upload' && 'text-primary-foreground')} />
            <span className="text-xs font-medium">Upload</span>
            <span className="text-[10px] text-muted-foreground">XML File</span>
          </button>
          
          <ChevronDown className="h-4 w-4 text-muted-foreground shrink-0" />
          
          <button
            type="button"
            onClick={() => handleStepClick('configure-rules')}
            disabled={!canAccessStep('configure-rules')}
            className={cn(
              'flex flex-col items-center gap-1.5 px-2 py-2 rounded-md transition-all w-full',
              step === 'configure-rules' && 'bg-primary text-primary-foreground shadow-sm',
              canAccessStep('configure-rules') && step !== 'configure-rules' && 'hover:bg-muted',
              !canAccessStep('configure-rules') && 'opacity-50 cursor-not-allowed'
            )}
          >
            <Settings className={cn('h-5 w-5', step === 'configure-rules' && 'text-primary-foreground')} />
            <span className="text-xs font-medium">Rules</span>
            <span className="text-[10px] text-muted-foreground">Analysis</span>
          </button>
          
          <ChevronDown className="h-4 w-4 text-muted-foreground shrink-0" />
          
          <button
            type="button"
            onClick={() => handleStepClick('analyze')}
            disabled={!canAccessStep('analyze')}
            className={cn(
              'flex flex-col items-center gap-1.5 px-2 py-2 rounded-md transition-all w-full',
              step === 'analyze' && 'bg-primary text-primary-foreground shadow-sm',
              canAccessStep('analyze') && step !== 'analyze' && 'hover:bg-muted',
              !canAccessStep('analyze') && 'opacity-50 cursor-not-allowed'
            )}
          >
            <Eye className={cn('h-5 w-5', step === 'analyze' && 'text-primary-foreground')} />
            <span className="text-xs font-medium">Analyze</span>
            <span className="text-[10px] text-muted-foreground">Structure</span>
          </button>
          
          <ChevronDown className="h-4 w-4 text-muted-foreground shrink-0" />
          
          <button
            type="button"
            onClick={() => handleStepClick('configure')}
            disabled={!canAccessStep('configure')}
            className={cn(
              'flex flex-col items-center gap-1.5 px-2 py-2 rounded-md transition-all w-full',
              step === 'configure' && 'bg-primary text-primary-foreground shadow-sm',
              canAccessStep('configure') && step !== 'configure' && 'hover:bg-muted',
              !canAccessStep('configure') && 'opacity-50 cursor-not-allowed'
            )}
          >
            <FileText className={cn('h-5 w-5', step === 'configure' && 'text-primary-foreground')} />
            <span className="text-xs font-medium">Configure</span>
            <span className="text-[10px] text-muted-foreground">Mapping</span>
          </button>
          
          <ChevronDown className="h-4 w-4 text-muted-foreground shrink-0" />
          
          <button
            type="button"
            onClick={() => handleStepClick('review')}
            disabled={!canAccessStep('review')}
            className={cn(
              'flex flex-col items-center gap-1.5 px-2 py-2 rounded-md transition-all w-full',
              step === 'review' && 'bg-primary text-primary-foreground shadow-sm',
              canAccessStep('review') && step !== 'review' && 'hover:bg-muted',
              !canAccessStep('review') && 'opacity-50 cursor-not-allowed'
            )}
          >
            <CheckCircle2 className={cn('h-5 w-5', step === 'review' && 'text-primary-foreground')} />
            <span className="text-xs font-medium">Review</span>
            <span className="text-[10px] text-muted-foreground">Complete</span>
          </button>
        </div>
      </div>

      {/* Main Content Area */}
      <div className="flex-1 min-w-0 space-y-4">
        {/* Error Display */}
        {error && (
          <div className="flex items-center gap-2 p-3 bg-destructive/10 border border-destructive/20 rounded-lg text-sm text-destructive">
            <AlertCircle className="h-4 w-4" />
            <span>{error}</span>
            <Button variant="ghost" size="sm" className="ml-auto h-6" onClick={handleClearError}>
              Ã—
            </Button>
          </div>
        )}

        {/* Step Content */}
        {step === 'upload' && (
          <UploadStep
            selectedFile={selectedFile}
            onFileSelect={handleFileSelect}
          />
        )}

        {step === 'configure-rules' && selectedFile && (
          <ConfigureRulesStep
            selectedFile={selectedFile}
            extracting={extracting}
            analysisRules={analysisRules}
            availableElements={availableElements}
            importingRules={importingRules}
            onRulesChange={setAnalysisRules}
            onImportRules={handleImportRules}
            onExportRules={handleExportRules}
          />
        )}

        {step === 'analyze' && <AnalyzeStep />}

        {step === 'configure' && analysis && mapping && (
          <ConfigureStep
            analysis={analysis}
            mapping={mapping}
            xmlPreview={xmlPreview}
            selectedElements={selectedElements}
            showStructure={showStructure}
            showMapping={showMapping}
            addingItems={addingItems}
            removingItems={removingItems}
            importingConfig={importingConfig}
            onShowStructureChange={setShowStructure}
            onShowMappingChange={setShowMapping}
            onMappingChange={handleMappingChange}
            onElementSelect={toggleElement}
            onElementsSelect={selectElements}
            onElementDelete={handleElementDelete}
            onAddElements={handleAddElementsToMapping}
            onAddingItemsChange={setAddingItems}
            onRemoveElements={handleRemoveElementsFromMapping}
            onImportConfig={handleImportConfig}
            onExportConfig={handleExportConfig}
          />
        )}

        {step === 'review' && <ReviewStep />}

        {/* Navigation Buttons */}
        <div className="flex justify-between gap-2 pt-4 border-t">
        {/* Back Button - Show on all steps except upload */}
        {step !== 'upload' && (
          <Button
            variant="outline"
            onClick={() => {
              if (step === 'configure-rules') {
                setStep('upload')
              } else if (step === 'analyze') {
                setStep('configure-rules')
              } else if (step === 'configure') {
                // Go back to configure-rules to allow re-analyzing with different rules
                setStep('configure-rules')
              } else if (step === 'review') {
                setStep('configure')
              }
            }}
          >
            Back
          </Button>
        )}
        
        {/* Forward/Action Buttons */}
        <div className="flex gap-2 ml-auto">
          {step === 'configure-rules' && selectedFile && (
            <>
              <Button variant="outline" onClick={handleReset}>
                Cancel
              </Button>
              <Button onClick={handleAnalyze}>
                Next: Configure XML
              </Button>
            </>
          )}
          
          {step === 'configure' && (
            <>
              <Button variant="outline" onClick={handleReset}>
                Cancel
              </Button>
              <Button onClick={handleGenerate}>
                Generate Model
              </Button>
            </>
          )}
          
          {step === 'review' && (
            <Button onClick={handleReset}>
              Import Another File
            </Button>
          )}
        </div>
        </div>
      </div>
    </div>
  )

  return wizardContent
}

